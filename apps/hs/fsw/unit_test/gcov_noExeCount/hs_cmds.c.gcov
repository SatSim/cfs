		/************************************************************************
		** File:
		**   $Id: hs_cmds.c.gcov 1.4 2011/10/17 16:44:29EDT aschoeni Exp  $
		**
		** Purpose:
		**   CFS Health and Safety (HS) command handling routines
		**
		**   $Log: hs_cmds.c.gcov  $
		**   Revision 1.4 2011/10/17 16:44:29EDT aschoeni 
		**   Updated Unit Tests
		**   Revision 1.11 2011/10/13 18:47:16EDT aschoeni 
		**   updated for hs utilization calibration changes
		**   Revision 1.10 2011/08/16 14:59:37EDT aschoeni 
		**   telemetry cmd counters are not 8 bit instead of 16
		**   Revision 1.9 2011/08/15 18:49:30EDT aschoeni 
		**   HS Unsubscibes when eventmon is disabled
		**   Revision 1.8 2010/11/19 17:58:27EST aschoeni 
		**   Added command to enable and disable CPU Hogging Monitoring
		**   Revision 1.7 2010/11/16 18:18:57EST aschoeni 
		**   Added support for Device Driver and ISR Execution Counters
		**   Revision 1.6 2010/10/01 15:18:40EDT aschoeni 
		**   Added Telemetry point to track message actions
		**   Revision 1.5 2010/09/29 18:27:06EDT aschoeni 
		**   Added Utilization Monitoring Telemetry
		**   Revision 1.4 2009/06/02 16:38:47EDT aschoeni 
		**   Updated telemetry and internal status to support HS Internal Status bit flags
		**   Revision 1.3 2009/05/21 16:10:56EDT aschoeni 
		**   Updated based on errors found during unit testing
		**   Revision 1.2 2009/05/04 17:44:34EDT aschoeni 
		**   Updated based on actions from Code Walkthrough
		**   Revision 1.1 2009/05/01 13:57:38EDT aschoeni 
		**   Initial revision
		**   Member added to project c:/MKSDATA/MKS-REPOSITORY/CFS-REPOSITORY/hs/fsw/src/project.pj
		**
		*************************************************************************/
		
		/************************************************************************
		** Includes
		*************************************************************************/
		#include "hs_app.h"
		#include "hs_cmds.h"
		#include "hs_custom.h"
		#include "hs_monitors.h"
		#include "hs_msgids.h"
		#include "hs_events.h"
		#include "hs_version.h"
		
		/************************************************************************
		** Local function prototypes
		*************************************************************************/
		
		/************************************************************************/
		/** \brief Housekeeping request
		**
		**  \par Description
		**       Processes an on-board housekeeping request message.
		**
		**  \par Assumptions, External Events, and Notes:
		**       This message does not affect the command execution counter
		**
		**  \param [in]   MessagePtr   A #CFE_SB_MsgPtr_t pointer that
		**                             references the software bus message
		**
		*************************************************************************/
		void HS_HousekeepingReq(CFE_SB_MsgPtr_t MessagePtr);
		
		/************************************************************************/
		/** \brief Noop command
		**
		**  \par Description
		**       Processes a noop ground command.
		**
		**  \par Assumptions, External Events, and Notes:
		**       None
		**
		**  \param [in]   MessagePtr   A #CFE_SB_MsgPtr_t pointer that
		**                             references the software bus message
		**
		**  \sa #HS_NOOP_CC
		**
		*************************************************************************/
		void HS_NoopCmd(CFE_SB_MsgPtr_t MessagePtr);
		
		/************************************************************************/
		/** \brief Reset counters command
		**
		**  \par Description
		**       Processes a reset counters ground command which will reset
		**       the following HS application counters to zero:
		**         - Command counter
		**         - Command error counter
		**
		**  \par Assumptions, External Events, and Notes:
		**       None
		**
		**  \param [in]   MessagePtr   A #CFE_SB_MsgPtr_t pointer that
		**                             references the software bus message
		**
		**  \sa #HS_RESET_CC
		**
		*************************************************************************/
		void HS_ResetCmd(CFE_SB_MsgPtr_t MessagePtr);
		
		/************************************************************************/
		/** \brief Process an enable critical applications monitor command
		**
		**  \par Description
		**       Allows the critical applications to be monitored.
		**
		**  \par Assumptions, External Events, and Notes:
		**       None
		**
		**  \param [in]   MessagePtr   A #CFE_SB_MsgPtr_t pointer that
		**                             references the software bus message
		**
		**  \sa #HS_ENABLE_APPMON_CC
		**
		*************************************************************************/
		void HS_EnableAppMonCmd(CFE_SB_MsgPtr_t MessagePtr);
		
		/************************************************************************/
		/** \brief Process a disable critical applications monitor command
		**
		**  \par Description
		**       Stops the critical applications from be monitored.
		**
		**  \par Assumptions, External Events, and Notes:
		**       None
		**
		**  \param [in]   MessagePtr   A #CFE_SB_MsgPtr_t pointer that
		**                             references the software bus message
		**
		**  \sa #HS_DISABLE_APPMON_CC
		**
		*************************************************************************/
		void HS_DisableAppMonCmd(CFE_SB_MsgPtr_t MessagePtr);
		
		/************************************************************************/
		/** \brief Process an enable critical events monitor command
		**
		**  \par Description
		**       Allows the critical events to be monitored.
		**
		**  \par Assumptions, External Events, and Notes:
		**       None
		**
		**  \param [in]   MessagePtr   A #CFE_SB_MsgPtr_t pointer that
		**                             references the software bus message
		**
		**  \sa #HS_ENABLE_EVENTMON_CC
		**
		*************************************************************************/
		void HS_EnableEventMonCmd(CFE_SB_MsgPtr_t MessagePtr);
		
		/************************************************************************/
		/** \brief Process a disable critical events monitor command
		**
		**  \par Description
		**       Stops the critical events from be monitored.
		**
		**  \par Assumptions, External Events, and Notes:
		**       None
		**
		**  \param [in]   MessagePtr   A #CFE_SB_MsgPtr_t pointer that
		**                             references the software bus message
		**
		**  \sa #HS_DISABLE_EVENTMON_CC
		**
		*************************************************************************/
		void HS_DisableEventMonCmd(CFE_SB_MsgPtr_t MessagePtr);
		
		/************************************************************************/
		/** \brief Process an enable aliveness indicator command
		**
		**  \par Description
		**       Allows the aliveness indicator to be output to the UART.
		**
		**  \par Assumptions, External Events, and Notes:
		**       None
		**
		**  \param [in]   MessagePtr   A #CFE_SB_MsgPtr_t pointer that
		**                             references the software bus message
		**
		**  \sa #HS_ENABLE_ALIVENESS_CC
		**
		*************************************************************************/
		void HS_EnableAlivenessCmd(CFE_SB_MsgPtr_t MessagePtr);
		
		/************************************************************************/
		/** \brief Process a disable aliveness indicator command
		**
		**  \par Description
		**       Stops the aliveness indicator from being output on the UART.
		**
		**  \par Assumptions, External Events, and Notes:
		**       None
		**
		**  \param [in]   MessagePtr   A #CFE_SB_MsgPtr_t pointer that
		**                             references the software bus message
		**
		**  \sa #HS_DISABLE_ALIVENESS_CC
		**
		*************************************************************************/
		void HS_DisableAlivenessCmd(CFE_SB_MsgPtr_t MessagePtr);
		
		/************************************************************************/
		/** \brief Process an enable CPU Hogging indicator command
		**
		**  \par Description
		**       Allows the CPU Hogging indicator to be output as an event.
		**
		**  \par Assumptions, External Events, and Notes:
		**       None
		**
		**  \param [in]   MessagePtr   A #CFE_SB_MsgPtr_t pointer that
		**                             references the software bus message
		**
		**  \sa #HS_ENABLE_CPUHOG_CC
		**
		*************************************************************************/
		void HS_EnableCPUHogCmd(CFE_SB_MsgPtr_t MessagePtr);
		
		/************************************************************************/
		/** \brief Process a disable CPU Hogging indicator command
		**
		**  \par Description
		**       Stops the CPU Hogging indicator from being output as an event.
		**
		**  \par Assumptions, External Events, and Notes:
		**       None
		**
		**  \param [in]   MessagePtr   A #CFE_SB_MsgPtr_t pointer that
		**                             references the software bus message
		**
		**  \sa #HS_DISABLE_CPUHOG_CC
		**
		*************************************************************************/
		void HS_DisableCPUHogCmd(CFE_SB_MsgPtr_t MessagePtr);
		
		/************************************************************************/
		/** \brief Process a reset resets performed command
		**
		**  \par Description
		**       Resets the count of HS performed resets maintained by HS.
		**
		**  \par Assumptions, External Events, and Notes:
		**       None
		**
		**  \param [in]   MessagePtr   A #CFE_SB_MsgPtr_t pointer that
		**                             references the software bus message
		**
		**  \sa #HS_SET_MAX_RESETS_CC
		**
		*************************************************************************/
		void HS_ResetResetsPerformedCmd(CFE_SB_MsgPtr_t MessagePtr);
		
		/************************************************************************/
		/** \brief Process a set max resets command
		**
		**  \par Description
		**       Sets the max number of HS performed resets to the specified value.
		**
		**  \par Assumptions, External Events, and Notes:
		**       None
		**
		**  \param [in]   MessagePtr   A #CFE_SB_MsgPtr_t pointer that
		**                             references the software bus message
		**
		**  \sa #HS_RESET_RESETS_PERFORMED_CC
		**
		*************************************************************************/
		void HS_SetMaxResetsCmd(CFE_SB_MsgPtr_t MessagePtr);
		
		/************************************************************************/
		/** \brief Refresh Critical Applications Monitor Status
		**
		**  \par Description
		**       This function gets called when HS detects that a new critical
		**       applications monitor table has been loaded or when a command
		**       to enable the critical applications monitor is received: it then
		**       refreshes the timeouts for application being monitored
		**
		**  \par Assumptions, External Events, and Notes:
		**       None
		**
		*************************************************************************/
		void HS_AppMonStatusRefresh(void);
		
		/************************************************************************/
		/** \brief Refresh Message Actions Status
		**
		**  \par Description
		**       This function gets called when HS detects that a new
		**       message actions table has been loaded: it then
		**       resets the cooldowns for all actions.
		**
		**  \par Assumptions, External Events, and Notes:
		**       None
		**
		*************************************************************************/
		void HS_MsgActsStatusRefresh(void);
		
		
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
		/*                                                                 */
		/* Process a command pipe message                                  */
		/*                                                                 */
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
		void HS_AppPipe(CFE_SB_MsgPtr_t MessagePtr)
          43    {
          43        CFE_SB_MsgId_t  MessageID   = 0;
          43        uint16          CommandCode = 0;
		
          43        MessageID = CFE_SB_GetMsgId(MessagePtr);
          43        switch (MessageID)
		    {
		
		        /*
		        ** Housekeeping telemetry request
		        */
		        case HS_SEND_HK_MID:
           8                HS_HousekeepingReq(MessagePtr);
           8                break;
		
		        /*
		        ** HS application commands...
		        */
		        case HS_CMD_MID:
		
          34                CommandCode = CFE_SB_GetCmdCode(MessagePtr);
          34                switch (CommandCode)
		            {
		                case HS_NOOP_CC:
           2                        HS_NoopCmd(MessagePtr);
           2                        break;
		
		                case HS_RESET_CC:
           2                        HS_ResetCmd(MessagePtr);
           2                        break;
		
		                case HS_ENABLE_APPMON_CC:
           2                        HS_EnableAppMonCmd(MessagePtr);
           2                        break;
		
		                case HS_DISABLE_APPMON_CC:
           2                        HS_DisableAppMonCmd(MessagePtr);
           2                        break;
		
		                case HS_ENABLE_EVENTMON_CC:
           3                        HS_EnableEventMonCmd(MessagePtr);
           3                        break;
		
		                case HS_DISABLE_EVENTMON_CC:
           3                        HS_DisableEventMonCmd(MessagePtr);
           3                        break;
		
		                case HS_ENABLE_ALIVENESS_CC:
           2                        HS_EnableAlivenessCmd(MessagePtr);
           2                        break;
		
		                case HS_DISABLE_ALIVENESS_CC:
           2                        HS_DisableAlivenessCmd(MessagePtr);
           2                        break;
		
		                case HS_RESET_RESETS_PERFORMED_CC:
           2                        HS_ResetResetsPerformedCmd(MessagePtr);
           2                        break;
		
		                case HS_SET_MAX_RESETS_CC:
           2                        HS_SetMaxResetsCmd(MessagePtr);
           2                        break;
		
		                case HS_ENABLE_CPUHOG_CC:
           2                        HS_EnableCPUHogCmd(MessagePtr);
           2                        break;
		
		                case HS_DISABLE_CPUHOG_CC:
           2                        HS_DisableCPUHogCmd(MessagePtr);
           2                        break;
		
		                default:
           8                        if (HS_CustomCommands(MessagePtr) != CFE_SUCCESS)
		                    {
           1                            CFE_EVS_SendEvent(HS_CC_ERR_EID, CFE_EVS_ERROR,
		                                          "Invalid command code: ID = 0x%04X, CC = %d",
		                                          MessageID, CommandCode);
		
           1                            HS_AppData.CmdErrCount++;
		                    }
           1                        break;
		
		            } /* end CommandCode switch */
           1                break;
		
		      /*
		      ** Unrecognized Message ID
		      */
		      default:
           1             HS_AppData.CmdErrCount++;
           1             CFE_EVS_SendEvent(HS_MID_ERR_EID, CFE_EVS_ERROR,
		                           "Invalid command pipe message ID: 0x%04X", MessageID);
          43             break;
		
		    } /* end MessageID switch */
		
          43        return;
		
		} /* End HS_AppPipe */
		
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
		/*                                                                 */
		/* Housekeeping request                                            */
		/*                                                                 */
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
		void HS_HousekeepingReq(CFE_SB_MsgPtr_t MessagePtr)
           8    {
           8        uint16 ExpectedLength = sizeof(HS_NoArgsCmd_t);
           8        uint32 AppId;
		#if HS_MAX_EXEC_CNT_SLOTS != 0
		    uint32 ExeCount;
		    uint32 TaskId;
		    CFE_ES_TaskInfo_t TaskInfo;
		#endif
           8        int32 Status;
           8        uint32 TableIndex;
		
		    /*
		    ** Verify message packet length
		    */
           8        if(HS_VerifyMsgLength(MessagePtr, ExpectedLength))
		    {
		        /*
		        ** Update HK variables
		        */
           7            HS_AppData.HkPacket.CmdCount                = (uint8) HS_AppData.CmdCount;
           7            HS_AppData.HkPacket.CmdErrCount             = (uint8) HS_AppData.CmdErrCount;
           7            HS_AppData.HkPacket.CurrentAppMonState      = HS_AppData.CurrentAppMonState;
           7            HS_AppData.HkPacket.CurrentEventMonState    = HS_AppData.CurrentEventMonState;
           7            HS_AppData.HkPacket.CurrentAlivenessState   = HS_AppData.CurrentAlivenessState;
           7            HS_AppData.HkPacket.CurrentCPUHogState      = HS_AppData.CurrentCPUHogState;
           7            HS_AppData.HkPacket.ResetsPerformed         = HS_AppData.CDSData.ResetsPerformed;
           7            HS_AppData.HkPacket.MaxResets               = HS_AppData.CDSData.MaxResets;
           7            HS_AppData.HkPacket.EventsMonitoredCount    = HS_AppData.EventsMonitoredCount;
           7            HS_AppData.HkPacket.MsgActExec              = HS_AppData.MsgActExec;
		
		        /*
		        ** Calculate the current number of invalid event monitor entries
		        */
           7            HS_AppData.HkPacket.InvalidEventMonCount    = 0;
		
         119            for(TableIndex = 0; TableIndex < HS_MAX_CRITICAL_EVENTS; TableIndex++)
		        {
         112                if(HS_AppData.EMTablePtr[TableIndex].ActionType != HS_EMT_ACT_NOACT)
		            {
          56                    Status = CFE_ES_GetAppIDByName(&AppId, HS_AppData.EMTablePtr[TableIndex].AppName);
		
          56                    if (Status == CFE_ES_ERR_APPNAME)
		                {
          22                        HS_AppData.HkPacket.InvalidEventMonCount++;
		
		                }
		            }
		        }
		
		        /*
		        ** Build the HK status flags byte
		        */
           7            HS_AppData.HkPacket.StatusFlags             = 0;
		#if HS_MAX_EXEC_CNT_SLOTS != 0
		        if(HS_AppData.ExeCountState == HS_STATE_ENABLED)
		        {
		            HS_AppData.HkPacket.StatusFlags   |= HS_LOADED_XCT;
		        }
		#endif
           7            if(HS_AppData.MsgActsState == HS_STATE_ENABLED)
		        {
           7                HS_AppData.HkPacket.StatusFlags   |= HS_LOADED_MAT;
		        }
           7            if(HS_AppData.AppMonLoaded == HS_STATE_ENABLED)
		        {
           7                HS_AppData.HkPacket.StatusFlags   |= HS_LOADED_AMT;
		        }
           7            if(HS_AppData.EventMonLoaded == HS_STATE_ENABLED)
		        {
           7                HS_AppData.HkPacket.StatusFlags   |= HS_LOADED_EMT;
		        }
           7            if(HS_AppData.CDSState == HS_STATE_ENABLED)
		        {
           7                HS_AppData.HkPacket.StatusFlags   |= HS_CDS_IN_USE;
		        }
		
		        /*
		        ** Update the AppMon Enables
		        */
          14            for(TableIndex = 0; TableIndex <= ((HS_MAX_CRITICAL_APPS -1) / HS_BITS_PER_APPMON_ENABLE); TableIndex++)
		        {
           7                HS_AppData.HkPacket.AppMonEnables[TableIndex] = HS_AppData.AppMonEnables[TableIndex];
		        }
		
		
           7            HS_AppData.HkPacket.UtilCpuAvg = HS_AppData.UtilCpuAvg;
           7            HS_AppData.HkPacket.UtilCpuPeak = HS_AppData.UtilCpuPeak;
		
		#if HS_MAX_EXEC_CNT_SLOTS != 0
		        /*
		        ** Add the execution counters
		        */
		        for(TableIndex = 0; TableIndex < HS_MAX_EXEC_CNT_SLOTS; TableIndex++)
		        {
		
		            ExeCount = HS_INVALID_EXECOUNT;
		
		            if((HS_AppData.ExeCountState == HS_STATE_ENABLED) &&
		               ((HS_AppData.XCTablePtr[TableIndex].ResourceType == HS_XCT_TYPE_APP_MAIN) ||
		                (HS_AppData.XCTablePtr[TableIndex].ResourceType == HS_XCT_TYPE_APP_CHILD)))
		            {
		
		                Status = OS_TaskGetIdByName(&TaskId, HS_AppData.XCTablePtr[TableIndex].ResourceName);
		
		                if (Status == OS_SUCCESS)
		                {
		                    Status = CFE_ES_GetTaskInfo(&TaskInfo, TaskId);
		                    if (Status == CFE_SUCCESS)
		                    {
		                        ExeCount = TaskInfo.ExecutionCounter;
		                    }
		
		                }
		
		            }
		            else if((HS_AppData.ExeCountState == HS_STATE_ENABLED) &&
		               ((HS_AppData.XCTablePtr[TableIndex].ResourceType == HS_XCT_TYPE_DEVICE) ||
		                (HS_AppData.XCTablePtr[TableIndex].ResourceType == HS_XCT_TYPE_ISR)))
		            {
		
		                Status = CFE_ES_GetGenCounterIDByName(&TaskId, HS_AppData.XCTablePtr[TableIndex].ResourceName);
		
		                if (Status == CFE_SUCCESS)
		                {
		                    CFE_ES_GetGenCount(TaskId, &ExeCount);
		                }
		
		            }
		            HS_AppData.HkPacket.ExeCounts[TableIndex] = ExeCount;
		
		        }        
		
		#endif
		
		        /*
		        ** Timestamp and send housekeeping packet
		        */
           7            CFE_SB_TimeStampMsg((CFE_SB_Msg_t *) &HS_AppData.HkPacket);
           7            CFE_SB_SendMsg((CFE_SB_Msg_t *) &HS_AppData.HkPacket);
		
		    } /* end HS_VerifyMsgLength if */
		
           8        return;
		
		} /* end HS_HousekeepingCmd */
		
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
		/*                                                                 */
		/* Noop command                                                    */
		/*                                                                 */
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
		void HS_NoopCmd(CFE_SB_MsgPtr_t MessagePtr)
           2    {
           2        uint16 ExpectedLength = sizeof(HS_NoArgsCmd_t);
		
		    /*
		    ** Verify message packet length
		    */
           2        if(HS_VerifyMsgLength(MessagePtr, ExpectedLength))
		    {
           1            HS_AppData.CmdCount++;
		
           1            CFE_EVS_SendEvent(HS_NOOP_INF_EID, CFE_EVS_INFORMATION,
		                        "No-op command: Version %d.%d.%d.%d",
		                         HS_MAJOR_VERSION,
		                         HS_MINOR_VERSION,
		                         HS_REVISION,
		                         HS_MISSION_REV);
		    }
		
           2        return;
		
		} /* end HS_NoopCmd */
		
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
		/*                                                                 */
		/* Reset counters command                                          */
		/*                                                                 */
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
		void HS_ResetCmd(CFE_SB_MsgPtr_t MessagePtr)
           2    {
           2        uint16 ExpectedLength = sizeof(HS_NoArgsCmd_t);
		
		    /*
		    ** Verify message packet length
		    */
           2        if(HS_VerifyMsgLength(MessagePtr, ExpectedLength))
		    {
           1            HS_ResetCounters();
		
           1            CFE_EVS_SendEvent(HS_RESET_DBG_EID, CFE_EVS_DEBUG,
		                          "Reset counters command");
		    }
		
           2        return;
		
		} /* end HS_ResetCmd */
		
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
		/*                                                                 */
		/* Reset housekeeping counters                                     */
		/*                                                                 */
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
		void HS_ResetCounters(void)
           1    {
           1        HS_AppData.CmdCount     = 0;
           1        HS_AppData.CmdErrCount  = 0;
           1        HS_AppData.EventsMonitoredCount   = 0;
           1        HS_AppData.MsgActExec = 0;
		
		    return;
		
		} /* end HS_ResetCounters */
		
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
		/*                                                                 */
		/* Enable critical applications monitor command                    */
		/*                                                                 */
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
		void HS_EnableAppMonCmd(CFE_SB_MsgPtr_t MessagePtr)
           2    {
           2        uint16            ExpectedLength = sizeof(HS_NoArgsCmd_t);
		
		    /*
		    ** Verify message packet length
		    */
           2        if(HS_VerifyMsgLength(MessagePtr, ExpectedLength))
		    {
           1            HS_AppData.CmdCount++;
           1            HS_AppMonStatusRefresh();
           1            HS_AppData.CurrentAppMonState = HS_STATE_ENABLED;
           1            CFE_EVS_SendEvent (HS_ENABLE_APPMON_DBG_EID,
		                           CFE_EVS_DEBUG,
		                           "Critical Application Monitoring Enabled");
		    }
		
           2        return;
		
		} /* end HS_EnableAppMonCmd */
		
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
		/*                                                                 */
		/* Disable critical applications monitor command                   */
		/*                                                                 */
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
		void HS_DisableAppMonCmd(CFE_SB_MsgPtr_t MessagePtr)
           2    {
           2        uint16            ExpectedLength = sizeof(HS_NoArgsCmd_t);
		
		    /*
		    ** Verify message packet length
		    */
           2        if(HS_VerifyMsgLength(MessagePtr, ExpectedLength))
		    {
           1            HS_AppData.CmdCount++;
           1            HS_AppData.CurrentAppMonState = HS_STATE_DISABLED;
           1            CFE_EVS_SendEvent (HS_DISABLE_APPMON_DBG_EID,
		                           CFE_EVS_DEBUG,
		                           "Critical Application Monitoring Disabled");
		    }
		
           2        return;
		
		} /* end HS_DisableAppMonCmd */
		
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
		/*                                                                 */
		/* Enable critical events monitor command                          */
		/*                                                                 */
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
		void HS_EnableEventMonCmd(CFE_SB_MsgPtr_t MessagePtr)
           3    {
           3        uint16            ExpectedLength = sizeof(HS_NoArgsCmd_t);
           3        int32             Status = CFE_SUCCESS;
		
		    /*
		    ** Verify message packet length
		    */
           3        if(HS_VerifyMsgLength(MessagePtr, ExpectedLength))
		    {
		       /*
		       ** Subscribe to Event Messages if currently disabled
		       */
           2           if (HS_AppData.CurrentEventMonState == HS_STATE_DISABLED)
		       {
		
           2              Status = CFE_SB_SubscribeEx(CFE_EVS_EVENT_MSG_MID,
		                                      HS_AppData.EventPipe,
		                                      CFE_SB_Default_Qos,
		                                      HS_EVENT_PIPE_DEPTH);
		
           2              if (Status != CFE_SUCCESS)
		          {
           1                 CFE_EVS_SendEvent(HS_EVENTMON_SUB_EID, CFE_EVS_ERROR,
		                 "Event Monitor Enable: Error Subscribing to Events,RC=0x%08X",Status);
           1                 HS_AppData.CmdErrCount++;
		          }
		       }
		
           2           if(Status == CFE_SUCCESS)
		       {
           1                HS_AppData.CmdCount++;
           1                HS_AppData.CurrentEventMonState = HS_STATE_ENABLED;
           1                CFE_EVS_SendEvent (HS_ENABLE_EVENTMON_DBG_EID,
		                               CFE_EVS_DEBUG,
		                               "Critical Event Monitoring Enabled");
		       }
		    }
		
           3        return;
		
		} /* end HS_EnableEventMonCmd */
		
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
		/*                                                                 */
		/* Disable critical events monitor command                         */
		/*                                                                 */
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
		void HS_DisableEventMonCmd(CFE_SB_MsgPtr_t MessagePtr)
           3    {
           3        uint16            ExpectedLength = sizeof(HS_NoArgsCmd_t);
           3        int32             Status = CFE_SUCCESS;
		
		    /*
		    ** Verify message packet length
		    */
           3        if(HS_VerifyMsgLength(MessagePtr, ExpectedLength))
		    {
		
		       /*
		       ** Unsubscribe from Event Messages if currently enabled
		       */
           2           if (HS_AppData.CurrentEventMonState == HS_STATE_ENABLED)
		       {
		
           2              Status =  CFE_SB_Unsubscribe ( CFE_EVS_EVENT_MSG_MID,
		                                         HS_AppData.EventPipe );
		
           2              if (Status != CFE_SUCCESS)
		          {
           1                 CFE_EVS_SendEvent(HS_EVENTMON_UNSUB_EID, CFE_EVS_ERROR,
		                 "Event Monitor Disable: Error Unsubscribing from Events,RC=0x%08X",Status);
           1                 HS_AppData.CmdErrCount++;
		          }
		       }
		
           2           if(Status == CFE_SUCCESS)
		       {
           1               HS_AppData.CmdCount++;
           1               HS_AppData.CurrentEventMonState = HS_STATE_DISABLED;
           1               CFE_EVS_SendEvent (HS_DISABLE_EVENTMON_DBG_EID,
		                              CFE_EVS_DEBUG,
		                              "Critical Event Monitoring Disabled");
		       }
		    }
		
           3        return;
		
		} /* end HS_DisableEventMonCmd */
		
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
		/*                                                                 */
		/* Enable aliveness indicator command                              */
		/*                                                                 */
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
		void HS_EnableAlivenessCmd(CFE_SB_MsgPtr_t MessagePtr)
           2    {
           2        uint16            ExpectedLength = sizeof(HS_NoArgsCmd_t);
		
		    /*
		    ** Verify message packet length
		    */
           2        if(HS_VerifyMsgLength(MessagePtr, ExpectedLength))
		    {
           1            HS_AppData.CmdCount++;
           1            HS_AppData.CurrentAlivenessState = HS_STATE_ENABLED;
           1            CFE_EVS_SendEvent (HS_ENABLE_ALIVENESS_DBG_EID,
		                           CFE_EVS_DEBUG,
		                           "Aliveness Indicator Enabled");
		    }
		
           2        return;
		
		} /* end HS_EnableAlivenessCmd */
		
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
		/*                                                                 */
		/* Disable aliveness indicator command                             */
		/*                                                                 */
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
		void HS_DisableAlivenessCmd(CFE_SB_MsgPtr_t MessagePtr)
           2    {
           2        uint16            ExpectedLength = sizeof(HS_NoArgsCmd_t);
		
		    /*
		    ** Verify message packet length
		    */
           2        if(HS_VerifyMsgLength(MessagePtr, ExpectedLength))
		    {
           1            HS_AppData.CmdCount++;
           1            HS_AppData.CurrentAlivenessState = HS_STATE_DISABLED;
           1            CFE_EVS_SendEvent (HS_DISABLE_ALIVENESS_DBG_EID,
		                           CFE_EVS_DEBUG,
		                           "Aliveness Indicator Disabled");
		    }
		
           2        return;
		
		} /* end HS_DisableAlivenessCmd */
		
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
		/*                                                                 */
		/* Enable cpu hogging indicator command                            */
		/*                                                                 */
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
		void HS_EnableCPUHogCmd(CFE_SB_MsgPtr_t MessagePtr)
           2    {
           2        uint16            ExpectedLength = sizeof(HS_NoArgsCmd_t);
		
		    /*
		    ** Verify message packet length
		    */
           2        if(HS_VerifyMsgLength(MessagePtr, ExpectedLength))
		    {
           1            HS_AppData.CmdCount++;
           1            HS_AppData.CurrentCPUHogState = HS_STATE_ENABLED;
           1            CFE_EVS_SendEvent (HS_ENABLE_CPUHOG_DBG_EID,
		                           CFE_EVS_DEBUG,
		                           "CPU Hogging Indicator Enabled");
		    }
		
           2        return;
		
		} /* end HS_EnableCPUHogCmd */
		
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
		/*                                                                 */
		/* Disable cpu hogging indicator command                           */
		/*                                                                 */
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
		void HS_DisableCPUHogCmd(CFE_SB_MsgPtr_t MessagePtr)
           2    {
           2        uint16            ExpectedLength = sizeof(HS_NoArgsCmd_t);
		
		    /*
		    ** Verify message packet length
		    */
           2        if(HS_VerifyMsgLength(MessagePtr, ExpectedLength))
		    {
           1            HS_AppData.CmdCount++;
           1            HS_AppData.CurrentCPUHogState = HS_STATE_DISABLED;
           1            CFE_EVS_SendEvent (HS_DISABLE_CPUHOG_DBG_EID,
		                           CFE_EVS_DEBUG,
		                           "CPU Hogging Indicator Disabled");
		    }
		
           2        return;
		
		} /* end HS_DisableCPUHogCmd */
		
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
		/*                                                                 */
		/* Reset processor resets performed count command                  */
		/*                                                                 */
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
		void HS_ResetResetsPerformedCmd(CFE_SB_MsgPtr_t MessagePtr)
           2    {
           2        uint16            ExpectedLength = sizeof(HS_NoArgsCmd_t);
		
		    /*
		    ** Verify message packet length
		    */
           2        if(HS_VerifyMsgLength(MessagePtr, ExpectedLength))
		    {
           1            HS_AppData.CmdCount++;
           1            HS_SetCDSData(0, HS_AppData.CDSData.MaxResets);
           1            CFE_EVS_SendEvent (HS_RESET_RESETS_DBG_EID, CFE_EVS_DEBUG,
		                           "Processor Resets Performed by HS Counter has been Reset");
		    }
		
           2        return;
		
		} /* end HS_ResetResetsPerformedCmd */
		
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
		/*                                                                 */
		/* Set max processor resets command                                */
		/*                                                                 */
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
		void HS_SetMaxResetsCmd(CFE_SB_MsgPtr_t MessagePtr)
           2    {
           2        uint16            ExpectedLength = sizeof(HS_SetMaxResetsCmd_t);
           2        HS_SetMaxResetsCmd_t  *CmdPtr;
		
		    /*
		    ** Verify message packet length
		    */
           2        if(HS_VerifyMsgLength(MessagePtr, ExpectedLength))
		    {
           1            HS_AppData.CmdCount++;
           1            CmdPtr = ((HS_SetMaxResetsCmd_t *)MessagePtr);
		
           1            HS_SetCDSData(HS_AppData.CDSData.ResetsPerformed, CmdPtr->MaxResets);
		
           1            CFE_EVS_SendEvent (HS_SET_MAX_RESETS_DBG_EID, CFE_EVS_DEBUG,
		                           "Max Resets Performable by HS has been set to %d", 
		                           HS_AppData.CDSData.MaxResets);
		    }
		
           2        return;
		
		} /* end HS_SetMaxResetsCmd */
		
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
		/*                                                                 */
		/* Verify message packet length                                    */
		/*                                                                 */
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
		boolean HS_VerifyMsgLength(CFE_SB_MsgPtr_t msg,
		                           uint16          ExpectedLength)
          39    {
          39       boolean result = TRUE;
          39       uint16  CommandCode;
          39       uint16  ActualLength;
          39       CFE_SB_MsgId_t MessageID;
		
		   /*
		   ** Verify the message packet length...
		   */
          39       ActualLength = CFE_SB_GetTotalMsgLength(msg);
          39       if (ExpectedLength != ActualLength)
		   {
          15           MessageID   = CFE_SB_GetMsgId(msg);
          15           CommandCode = CFE_SB_GetCmdCode(msg);
		
          15           if (MessageID == HS_SEND_HK_MID)
		       {
		           /*
		           ** For a bad HK request, just send the event. We only increment
		           ** the error counter for ground commands and not internal messages.
		           */
           1               CFE_EVS_SendEvent(HS_HKREQ_LEN_ERR_EID, CFE_EVS_ERROR,
		                   "Invalid HK request msg length: ID = 0x%04X, CC = %d, Len = %d, Expected = %d",
		                   MessageID, CommandCode, ActualLength, ExpectedLength);
		       }
		       else
		       {
		           /*
		           ** All other cases, increment error counter
		           */
          14               CFE_EVS_SendEvent(HS_LEN_ERR_EID, CFE_EVS_ERROR,
		                   "Invalid msg length: ID = 0x%04X, CC = %d, Len = %d, Expected = %d",
		                   MessageID, CommandCode, ActualLength, ExpectedLength);
          14               HS_AppData.CmdErrCount++;
		       }
		
          15           result = FALSE;
		    }
		
          39        return(result);
		
		} /* End of HS_VerifyMsgLength */
		
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
		/*                                                                 */
		/* Acquire table pointers                                          */
		/*                                                                 */
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
		void HS_AcquirePointers(void)
          83    {
          83        int32  Status;
		
		    /*
		    ** Release the table (AppMon)
		    */
          83        CFE_TBL_ReleaseAddress(HS_AppData.AMTableHandle);
		
		    /*
		    ** Manage the table (AppMon)
		    */
          83        CFE_TBL_Manage(HS_AppData.AMTableHandle);
		
		    /*
		    ** Get a pointer to the table (AppMon)
		    */
          83        Status = CFE_TBL_GetAddress((void *)&HS_AppData.AMTablePtr, HS_AppData.AMTableHandle);
		
		    /*
		    ** If there is a new table, refresh status (AppMon)
		    */
          83        if (Status == CFE_TBL_INFO_UPDATED)
		    {
           9            HS_AppMonStatusRefresh();
		    }
		
		    /*
		    ** If Address acquisition fails and currently enabled, report and disable (AppMon)
		    */
          83        if(Status < CFE_SUCCESS)
		    {
		        /*
		        ** Only report and disable if enabled or the table was previously loaded (AppMon)
		        */
           2            if ((HS_AppData.AppMonLoaded == HS_STATE_ENABLED) ||
		            (HS_AppData.CurrentAppMonState == HS_STATE_ENABLED))
		        {
           1                CFE_EVS_SendEvent(HS_APPMON_GETADDR_ERR_EID, CFE_EVS_ERROR,
		                              "Error getting AppMon Table address, RC=0x%08X, Application Monitoring Disabled",
		                              Status);
           1                HS_AppData.CurrentAppMonState = HS_STATE_DISABLED;
           1                HS_AppData.AppMonLoaded = HS_STATE_DISABLED;
		        }
		    }
		    /*
		    ** Otherwise, mark that the table is loaded (AppMon)
		    */
		    else
		    {
          81            HS_AppData.AppMonLoaded = HS_STATE_ENABLED;
		    }
		
		    /*
		    ** Release the table (EventMon)
		    */
          83        CFE_TBL_ReleaseAddress(HS_AppData.EMTableHandle);
		
		    /*
		    ** Manage the table (EventMon)
		    */
          83        CFE_TBL_Manage(HS_AppData.EMTableHandle);
		
		    /*
		    ** Get a pointer to the table (EventMon)
		    */
          83        Status = CFE_TBL_GetAddress((void *)&HS_AppData.EMTablePtr, HS_AppData.EMTableHandle);
		
		    /*
		    ** If Address acquisition fails and currently enabled, report and disable (EventMon)
		    */
          83        if(Status < CFE_SUCCESS)
		    {
		        /*
		        ** Only report and disable if enabled or the table was previously loaded (EventMon)
		        */
           2            if ((HS_AppData.EventMonLoaded == HS_STATE_ENABLED) ||
		            (HS_AppData.CurrentEventMonState == HS_STATE_ENABLED))
		        {
           1                CFE_EVS_SendEvent(HS_EVENTMON_GETADDR_ERR_EID, CFE_EVS_ERROR,
		                              "Error getting EventMon Table address, RC=0x%08X, Event Monitoring Disabled",
		                              Status);
		
           1                if (HS_AppData.CurrentEventMonState == HS_STATE_ENABLED)
		            {
           1                    Status =  CFE_SB_Unsubscribe ( CFE_EVS_EVENT_MSG_MID,
		                                               HS_AppData.EventPipe );
		
           1                    if (Status != CFE_SUCCESS)
		                {
           1                        CFE_EVS_SendEvent(HS_BADEMT_UNSUB_EID, CFE_EVS_ERROR,
		                        "Error Unsubscribing from Events,RC=0x%08X",Status);
		                }
		            }
		
           1                HS_AppData.CurrentEventMonState = HS_STATE_DISABLED;
           1                HS_AppData.EventMonLoaded = HS_STATE_DISABLED;
		
		        }
		    }
		    /*
		    ** Otherwise, mark that the table is loaded (EventMon)
		    */
		    else
		    {
          81            HS_AppData.EventMonLoaded = HS_STATE_ENABLED;
		    }
		
		    /*
		    ** Release the table (MsgActs)
		    */
          83        CFE_TBL_ReleaseAddress(HS_AppData.MATableHandle);
		
		    /*
		    ** Manage the table (MsgActs)
		    */
          83        CFE_TBL_Manage(HS_AppData.MATableHandle);
		
		    /*
		    ** Get a pointer to the table (MsgActs)
		    */
          83        Status = CFE_TBL_GetAddress((void *)&HS_AppData.MATablePtr, HS_AppData.MATableHandle);
		
		    /*
		    ** If there is a new table, refresh status (MsgActs)
		    */
          83        if (Status == CFE_TBL_INFO_UPDATED)
		    {
           9            HS_MsgActsStatusRefresh();
		    }
		
		    /*
		    ** If Address acquisition fails report and disable (MsgActs)
		    */
          83        if(Status < CFE_SUCCESS)
		    {
		        /*
		        ** To prevent redundant reporting, only report if enabled (MsgActs)
		        */
           2            if(HS_AppData.MsgActsState == HS_STATE_ENABLED)
		        {
           1                CFE_EVS_SendEvent(HS_MSGACTS_GETADDR_ERR_EID, CFE_EVS_ERROR,
		                              "Error getting MsgActs Table address, RC=0x%08X",
		                              Status);
           1                HS_AppData.MsgActsState = HS_STATE_DISABLED;
		        }
		    }
		    /*
		    ** Otherwise, make sure it is enabled (MsgActs)
		    */
		    else
		    {
          81            HS_AppData.MsgActsState = HS_STATE_ENABLED;
		    }
		
		#if HS_MAX_EXEC_CNT_SLOTS != 0
		    /*
		    ** Release the table (ExeCount)
		    */
		    CFE_TBL_ReleaseAddress(HS_AppData.XCTableHandle);
		
		    /*
		    ** Manage the table (ExeCount)
		    */
		    CFE_TBL_Manage(HS_AppData.XCTableHandle);
		
		    /*
		    ** Get a pointer to the table (ExeCount)
		    */
		    Status = CFE_TBL_GetAddress((void *)&HS_AppData.XCTablePtr, HS_AppData.XCTableHandle);
		
		    /*
		    ** If Address acquisition fails report and disable (ExeCount)
		    */
		    if(Status < CFE_SUCCESS)
		    {
		        /*
		        ** To prevent redundant reporting, only report if enabled (ExeCount)
		        */
		        if(HS_AppData.ExeCountState == HS_STATE_ENABLED)
		        {
		            CFE_EVS_SendEvent(HS_EXECOUNT_GETADDR_ERR_EID, CFE_EVS_ERROR,
		                              "Error getting ExeCount Table address, RC=0x%08X",
		                              Status);
		           HS_AppData.ExeCountState = HS_STATE_DISABLED;
		        }
		    }
		    /*
		    ** Otherwise, make sure it is enabled (ExeCount)
		    */
		    else
		    {
		        HS_AppData.ExeCountState = HS_STATE_ENABLED;
		    }
		
		#endif
		
          83        return;
		
		} /* End of HS_AcquirePointers */
		
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
		/*                                                                 */
		/* Refresh AppMon Status (on Table Update or Enable)               */
		/*                                                                 */
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
		void HS_AppMonStatusRefresh(void)
          10    {
          10        uint32  TableIndex;
          10        uint32  EnableIndex;
		
		    /*
		    ** Clear all AppMon Enable bits
		    */
          20        for (EnableIndex = 0; EnableIndex <= ((HS_MAX_CRITICAL_APPS -1) / HS_BITS_PER_APPMON_ENABLE); EnableIndex++ )
		    {
          10            HS_AppData.AppMonEnables[EnableIndex] = 0;
		
		    }
		
		    /*
		    ** Set AppMon enable bits and reset Countups and Exec Counter comparisons
		    */
         330        for (TableIndex = 0; TableIndex < HS_MAX_CRITICAL_APPS; TableIndex++ )
		    {
         320            HS_AppData.AppMonLastExeCount[TableIndex] = 0;
		
         320            if ((HS_AppData.AMTablePtr[TableIndex].CycleCount == 0) ||
		            (HS_AppData.AMTablePtr[TableIndex].ActionType == HS_AMT_ACT_NOACT))
		        {
         240                HS_AppData.AppMonCheckInCountdown[TableIndex] = 0;
		        }
		        else
		        {
          80                HS_AppData.AppMonCheckInCountdown[TableIndex] = HS_AppData.AMTablePtr[TableIndex].CycleCount;
		            CFE_SET((HS_AppData.AppMonEnables[TableIndex / HS_BITS_PER_APPMON_ENABLE]),
          80                        (TableIndex % HS_BITS_PER_APPMON_ENABLE));
		        }
		
		    }
		
          10        return;
		
		} /* end HS_AppMonStatusRefresh */
		
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
		/*                                                                 */
		/* Refresh MsgActs Status (on Table Update or Enable)              */
		/*                                                                 */
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
		void HS_MsgActsStatusRefresh(void)
           9    {
           9        uint32  TableIndex;
		
		    /*
		    ** Clear all MsgActs Cooldowns
		    */
          81        for (TableIndex = 0; TableIndex < HS_MAX_MSG_ACT_TYPES; TableIndex++)
		    {
          72            HS_AppData.MsgActCooldown[TableIndex] = 0;
		    }
		
           9        return;
		
		} /* end HS_MsgActsStatusRefresh */
		
		/************************/
		/*  End of File Comment */
		/************************/
