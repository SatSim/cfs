		/*
		** $Id: sch_cmds.c.gcov 1.4 2011/06/30 21:03:41EDT aschoeni Exp  $
		**
		** Purpose: Scheduler (SCH) application command handling
		**
		** Author:
		**
		** Notes:
		**
		** $Log: sch_cmds.c.gcov  $
		** Revision 1.4 2011/06/30 21:03:41EDT aschoeni 
		** Updated unit tests for new timers and customization interfaces
		** Revision 1.3 2009/06/12 14:41:00EDT rmcgraw 
		** DCR82191:1 Changed OS_Mem function calls to CFE_PSP_Mem
		** Revision 1.2 2009/03/27 00:24:21EDT dkobe 
		** Added consecutive noisy major frame counter and platform config parameter to compare counter to
		** Revision 1.1 2008/10/16 15:08:34EDT dkobe 
		** Initial revision
		** Member added to project c:/MKSDATA/MKS-REPOSITORY/CFS-REPOSITORY/sch/fsw/src/project.pj
		*/
		
		/*************************************************************************
		**
		** Include section
		**
		**************************************************************************/
		
		#include "cfe.h"
		#include "sch_msgids.h"
		
		#include "sch_msg.h"
		#include "sch_events.h"
		#include "sch_app.h"
		#include "sch_cmds.h"
		#include "sch_version.h"
		
		#include "cfe_time_msg.h"
		
		
		/*************************************************************************
		**
		** Macro definitions
		**
		**************************************************************************/
		
		/*************************************************************************
		**
		** Type definitions
		**
		**************************************************************************/
		
		/*
		** (none)
		*/
		
		/*************************************************************************
		**
		** Imported data
		**
		**************************************************************************/
		
		/*
		** (none)
		*/
		
		/*************************************************************************
		**
		** Exported data
		**
		**************************************************************************/
		
		/*
		** Application global data
		*/
		extern SCH_AppData_t           SCH_AppData;
		
		/*************************************************************************
		**
		** File data
		**
		**************************************************************************/
		
		/*
		** (none)
		*/
		
		/*************************************************************************
		** Local function prototypes
		**************************************************************************/
		/************************************************************************/
		/** \brief Process housekeeping request
		**  
		**  \par Description
		**       Processes an on-board housekeeping request message.
		**
		**  \par Assumptions, External Events, and Notes:
		**       This command does not affect the command execution counter
		**       
		**  \param [in]   MessagePtr   A #CFE_SB_MsgPtr_t pointer that
		**                             references the software bus message 
		**       
		**  \returns
		**  \retcode #CFE_SUCCESS  \retdesc \copydoc CFE_SUCCESS \endcode
		**  \retstmt Return codes from #CFE_EVS_Register         \endcode
		**  \retstmt Return codes from #CFE_SB_CreatePipe        \endcode
		**  \retstmt Return codes from #CFE_SB_Subscribe         \endcode
		**  \endreturns
		**
		*************************************************************************/
		int32 SCH_HousekeepingCmd(CFE_SB_MsgPtr_t MessagePtr);
		
		/*
		** Application command handlers
		*/
		/************************************************************************/
		/** \brief Process noop command
		**  
		**  \par Description
		**       Processes a noop ground command.
		**
		**  \par Assumptions, External Events, and Notes:
		**       None
		**       
		**  \param [in]   MessagePtr   A #CFE_SB_MsgPtr_t pointer that
		**                             references the software bus message 
		**
		**  \sa #SCH_NOOP_CC
		**
		*************************************************************************/
		void SCH_NoopCmd(CFE_SB_MsgPtr_t MessagePtr);
		
		/************************************************************************/
		/** \brief Process reset counters command
		**  
		**  \par Description
		**       Processes a reset counters ground command which will reset
		**       the Scheduler commmand error, command execution and performance
		**       statistics counters to zero.
		**
		**  \par Assumptions, External Events, and Notes:
		**       None
		**       
		**  \param [in]   MessagePtr   A #CFE_SB_MsgPtr_t pointer that
		**                             references the software bus message 
		**
		**  \sa #SCH_RESET_CC
		**
		*************************************************************************/
		void SCH_ResetCmd(CFE_SB_MsgPtr_t MessagePtr);
		
		/************************************************************************/
		/** \brief Enable a Single Activity Command
		**  
		**  \par Description
		**       Command to Enable a specific activity in the Schedule 
		**       Definition Table.
		**
		**  \par Assumptions, External Events, and Notes:
		**       None
		**       
		**  \param [in]   MessagePtr     A #CFE_SB_MsgPtr_t pointer that
		**                               references the software bus message 
		**       
		**  \sa #SCH_ENABLE_CC, #SCH_DISABLE_CC, #SCH_ENABLE_GROUP_CC, #SCH_DISABLE_GROUP_CC
		**
		*************************************************************************/
		void SCH_EnableCmd(CFE_SB_MsgPtr_t MessagePtr);
		
		/************************************************************************/
		/** \brief Disable a Single Activity Command
		**  
		**  \par Description
		**       Command to Disable a specific activity in the Schedule 
		**       Definition Table.
		**
		**  \par Assumptions, External Events, and Notes:
		**       None
		**       
		**  \param [in]   MessagePtr     A #CFE_SB_MsgPtr_t pointer that
		**                               references the software bus message 
		**       
		**  \sa #SCH_ENABLE_CC, #SCH_DISABLE_CC, #SCH_ENABLE_GROUP_CC, #SCH_DISABLE_GROUP_CC
		**
		*************************************************************************/
		void SCH_DisableCmd(CFE_SB_MsgPtr_t MessagePtr);
		
		/************************************************************************/
		/** \brief Enable a Group and/or Multi-Group(s) Command
		**  
		**  \par Description
		**       Command to Enable a single Group and/or one or more Multi-Groups
		**       of activities.
		**
		**  \par Assumptions, External Events, and Notes:
		**       None
		**       
		**  \param [in]   MessagePtr     A #CFE_SB_MsgPtr_t pointer that
		**                               references the software bus message 
		**       
		**  \sa #SCH_ENABLE_CC, #SCH_DISABLE_CC, #SCH_ENABLE_GROUP_CC, #SCH_DISABLE_GROUP_CC
		**
		*************************************************************************/
		void SCH_EnableGroupCmd(CFE_SB_MsgPtr_t MessagePtr);
		
		/************************************************************************/
		/** \brief Disable a Group and/or Multi-Group(s) Command
		**  
		**  \par Description
		**       Command to Disable a single Group and/or one or more Multi-Groups
		**       of activities.
		**
		**  \par Assumptions, External Events, and Notes:
		**       None
		**       
		**  \param [in]   MessagePtr     A #CFE_SB_MsgPtr_t pointer that
		**                               references the software bus message 
		**       
		**  \sa #SCH_ENABLE_CC, #SCH_DISABLE_CC, #SCH_ENABLE_GROUP_CC, #SCH_DISABLE_GROUP_CC
		**
		*************************************************************************/
		void SCH_DisableGroupCmd(CFE_SB_MsgPtr_t MessagePtr);
		
		/************************************************************************/
		/** \brief Enables Major Frame Synchronization
		**  
		**  \par Description
		**       Command to enable synchronization of Schedule Definition Table to
		**       the Major Frame Sync signal.  The synchronization can become
		**       unsynchronized when the Major Frame signal becomes noisy.
		**
		**  \par Assumptions, External Events, and Notes:
		**       None
		**       
		**  \param [in]   MessagePtr     A #CFE_SB_MsgPtr_t pointer that
		**                               references the software bus message 
		**       
		**  \sa #SCH_ENABLE_CC, #SCH_DISABLE_CC, #SCH_ENABLE_GROUP_CC, #SCH_DISABLE_GROUP_CC
		**
		*************************************************************************/
		void SCH_EnableSyncCmd(CFE_SB_MsgPtr_t MessagePtr);
		
		/************************************************************************/
		/** \brief Creates and sends diagnostic message packet
		**  
		**  \par Description
		**       Command to send the Scheduler diagnostic message.
		**
		**  \par Assumptions, External Events, and Notes:
		**       None
		**       
		**  \param [in]   MessagePtr     A #CFE_SB_MsgPtr_t pointer that
		**                               references the software bus message 
		**       
		*************************************************************************/
		void SCH_SendDiagTlmCmd(CFE_SB_MsgPtr_t MessagePtr);
		
		/************************************************************************/
		/** \brief Updates appropriate command counters following command execution
		**  
		**  \par Description
		**       This function updates the ground or on-board command counter or
		**       command error counter depending upon the success of the command
		**       and where it originated.
		**
		**  \par Assumptions, External Events, and Notes:
		**       None
		**       
		**  \param [in]   GoodCommand    Indicates the command was successfully
		**                               performed (=TRUE) or contained an error
		**                               (=FALSE). 
		**       
		*************************************************************************/
		void SCH_PostCommandResult(boolean GoodCommand);
		
		/************************************************************************/
		/** \brief Verifies the length of the specified message
		**  
		**  \par Description
		**       This function determines whether the specified message is of the
		**       specified expected length.  If not, an event message is generated
		**       and the appropriate command error counter is incremented.  If the
		**       message length is appropriate, then the appropriate command counter
		**       is incremented.
		**
		**  \par Assumptions, External Events, and Notes:
		**       None
		**       
		**       
		**  \param [in]   MessagePtr     A #CFE_SB_MsgPtr_t pointer that
		**                               references the software bus message 
		**       
		**  \param [in]   ExpectedLength The size, in bytes, that the specified
		**                               message should be equal to. 
		**       
		**  \returns
		**  \retcode #CFE_SUCCESS  \retdesc \copydoc CFE_SUCCESS \endcode
		**  \retstmt Return codes from #CFE_EVS_Register         \endcode
		**  \retstmt Return codes from #CFE_SB_CreatePipe        \endcode
		**  \retstmt Return codes from #CFE_SB_Subscribe         \endcode
		**  \endreturns
		**
		*************************************************************************/
		int32 SCH_VerifyCmdLength (CFE_SB_MsgPtr_t MessagePtr, uint32 ExpectedLength);
		
		
		/*******************************************************************
		**
		** SCH_AppPipe
		**
		** NOTE: For complete prolog information, see 'sch_cmds.h'
		********************************************************************/
		
		int32 SCH_AppPipe(CFE_SB_MsgPtr_t MessagePtr)
         135    {
         135        int32           Result = CFE_SUCCESS;
         135        CFE_SB_MsgId_t  MessageID = 0;
         135        uint16          CommandCode = 0;
		
         135        MessageID = CFE_SB_GetMsgId(MessagePtr);
         135        switch (MessageID)
		    {
		        /*
		        ** Housekeeping telemetry request
		        */
		        case SCH_SEND_HK_MID:
          67                Result = SCH_HousekeepingCmd(MessagePtr);
          67                break;
		
		        /*
		        ** SCH ground commands
		        */
		        case SCH_CMD_MID:
		
          67                CommandCode = CFE_SB_GetCmdCode(MessagePtr);
          67                switch (CommandCode)
		            {
		                case SCH_NOOP_CC:
           6                        SCH_NoopCmd(MessagePtr);
           6                        break;
		
		                case SCH_RESET_CC:
           2                        SCH_ResetCmd(MessagePtr);
           2                        break;
		
		                case SCH_ENABLE_CC:
           6                        SCH_EnableCmd(MessagePtr);
           6                        break;
		
		                case SCH_DISABLE_CC:
           5                        SCH_DisableCmd(MessagePtr);
           5                        break;
		
		                case SCH_ENABLE_GROUP_CC:
           6                        SCH_EnableGroupCmd(MessagePtr);
           6                        break;
		
		                case SCH_DISABLE_GROUP_CC:
           6                        SCH_DisableGroupCmd(MessagePtr);
           6                        break;
		
		                case SCH_ENABLE_SYNC_CC:
           2                        SCH_EnableSyncCmd(MessagePtr);
           2                        break;
		
		                case SCH_SEND_DIAG_TLM_CC:
          29                        SCH_SendDiagTlmCmd(MessagePtr);
          29                        break;
		
		                /*
		                ** SCH ground commands with unknown command codes...
		                */
		                default:
           5                        CFE_EVS_SendEvent(SCH_CC_ERR_EID, CFE_EVS_ERROR,
		                                      "Invalid command code: ID = 0x%04X, CC = %d",
		                                      MessageID, CommandCode);
		
           5                        SCH_AppData.ErrCounter++;
           5                        break;
		            }
           5                break;
		
		        /*
		        ** Unknown message ID's
		        */
		        default:
           1                CFE_EVS_SendEvent(SCH_MD_ERR_EID, CFE_EVS_ERROR,
		                              "Msg with Invalid message ID Rcvd -- ID = 0x%04X",
		                              MessageID);
         135                break;
		    }
		
         135        return(Result);
		
		} /* End of SCH_AppPipe() */
		
		
		/*******************************************************************
		**
		** SCH_HousekeepingCmd
		**
		** NOTE: For complete prolog information, see above
		********************************************************************/
		
		int32 SCH_HousekeepingCmd(CFE_SB_MsgPtr_t MessagePtr)
          67    {
          67        int32  TableResult = SCH_SUCCESS;
		
          67        if(SCH_VerifyCmdLength(MessagePtr, sizeof(SCH_NoArgsCmd_t)) == SCH_SUCCESS)
		    {
		        /*
		        ** Update contents of Housekeeping Packet
		        */
          66            SCH_AppData.HkPacket.CmdCounter                   = SCH_AppData.CmdCounter;
          66            SCH_AppData.HkPacket.ErrCounter                   = SCH_AppData.ErrCounter;
          66            SCH_AppData.HkPacket.ScheduleActivitySuccessCount = SCH_AppData.ScheduleActivitySuccessCount;
          66            SCH_AppData.HkPacket.ScheduleActivityFailureCount = SCH_AppData.ScheduleActivityFailureCount;
          66            SCH_AppData.HkPacket.SlotsProcessedCount          = SCH_AppData.SlotsProcessedCount;
          66            SCH_AppData.HkPacket.SkippedSlotsCount            = SCH_AppData.SkippedSlotsCount;
          66            SCH_AppData.HkPacket.MultipleSlotsCount           = SCH_AppData.MultipleSlotsCount;
          66            SCH_AppData.HkPacket.SameSlotCount                = SCH_AppData.SameSlotCount;
          66            SCH_AppData.HkPacket.BadTableDataCount            = SCH_AppData.BadTableDataCount;
          66            SCH_AppData.HkPacket.TableVerifySuccessCount      = SCH_AppData.TableVerifySuccessCount;
          66            SCH_AppData.HkPacket.TableVerifyFailureCount      = SCH_AppData.TableVerifyFailureCount;
          66            SCH_AppData.HkPacket.TablePassCount               = SCH_AppData.TablePassCount;
          66            SCH_AppData.HkPacket.ValidMajorFrameCount         = SCH_AppData.ValidMajorFrameCount;
          66            SCH_AppData.HkPacket.MissedMajorFrameCount        = SCH_AppData.MissedMajorFrameCount;
          66            SCH_AppData.HkPacket.UnexpectedMajorFrameCount    = SCH_AppData.UnexpectedMajorFrameCount;
          66            SCH_AppData.HkPacket.MinorFramesSinceTone         = SCH_AppData.MinorFramesSinceTone;
          66            SCH_AppData.HkPacket.NextSlotNumber               = SCH_AppData.NextSlotNumber;
          66            SCH_AppData.HkPacket.LastSyncMETSlot              = SCH_AppData.LastSyncMETSlot;
          66            SCH_AppData.HkPacket.IgnoreMajorFrame             = SCH_AppData.IgnoreMajorFrame;
          66            SCH_AppData.HkPacket.UnexpectedMajorFrame         = SCH_AppData.UnexpectedMajorFrame;
          66            SCH_AppData.HkPacket.SyncToMET                    = SCH_AppData.SyncToMET;
          66            SCH_AppData.HkPacket.MajorFrameSource             = SCH_AppData.MajorFrameSource;
		        
		        /*
		        ** Timestamps and send housekeeping packet
		        */
          66            CFE_SB_TimeStampMsg((CFE_SB_Msg_t *) &SCH_AppData.HkPacket);
          66            CFE_SB_SendMsg((CFE_SB_Msg_t *) &SCH_AppData.HkPacket);
		
		        /*
		        ** Reset "high rate" event filters
		        */
          66            CFE_EVS_ResetAllFilters();
		    }
		
		    /*
		    ** Note:
		    **
		    **   The following table functions will give the cFE Table Manager
		    **   a chance to update the tables used by this application.  If
		    **   there is an error (very unlikely) the return value will cause
		    **   us to fall out of the main process loop and terminate the SCH
		    **   task.  It may sound extreme but there is nothing for the
		    **   Scheduler to do if it cannot access both the message
		    **   and schedule tables.
		    */
          67        CFE_TBL_ReleaseAddress(SCH_AppData.ScheduleTableHandle);
          67        CFE_TBL_ReleaseAddress(SCH_AppData.MessageTableHandle);
		
          67        TableResult = SCH_AcquirePointers();
		
          67        return(TableResult);
		
		} /* End of SCH_HousekeepingCmd() */
		
		
		/*******************************************************************
		**
		** SCH_NoopCmd
		**
		** NOTE: For complete prolog information, see above
		********************************************************************/
		
		void SCH_NoopCmd(CFE_SB_MsgPtr_t MessagePtr)
           6    {
           6        if(SCH_VerifyCmdLength(MessagePtr, sizeof(SCH_NoArgsCmd_t)) != SCH_SUCCESS)
		    {
           1            SCH_AppData.ErrCounter++;
		    }
		    else
		    {
		        /*
		        ** This command is used primarily for "aliveness" testing
		        */
           5            SCH_AppData.CmdCounter++;
		
           5            CFE_EVS_SendEvent(SCH_NOOP_CMD_EID, CFE_EVS_INFORMATION,
		                          "NO-op command. Version %d.%d.%d.%d",
		                          SCH_MAJOR_VERSION,
		                          SCH_MINOR_VERSION,
		                          SCH_REVISION,
		                          SCH_MISSION_REV);
		    }
		
           6        return;
		
		} /* End of SCH_NoopCmd() */
		
		
		/*******************************************************************
		**
		** SCH_ResetCmd
		**
		** NOTE: For complete prolog information, see above
		********************************************************************/
		
		void SCH_ResetCmd(CFE_SB_MsgPtr_t MessagePtr)
           2    {
           2        if(SCH_VerifyCmdLength(MessagePtr, sizeof(SCH_NoArgsCmd_t)) != SCH_SUCCESS)
		    {
           1            SCH_AppData.ErrCounter++;
		    }
		    else
		    {
		        /*
		        ** Reset housekeeping counters
		        */
           1            SCH_AppData.CmdCounter      = 0;
           1            SCH_AppData.ErrCounter      = 0;
		
           1            SCH_AppData.ScheduleActivitySuccessCount = 0;
           1            SCH_AppData.ScheduleActivityFailureCount = 0;
		
           1            SCH_AppData.SlotsProcessedCount = 0;
           1            SCH_AppData.SkippedSlotsCount   = 0;
           1            SCH_AppData.MultipleSlotsCount  = 0;
           1            SCH_AppData.SameSlotCount       = 0;
           1            SCH_AppData.BadTableDataCount   = 0;
		
           1            SCH_AppData.TableVerifySuccessCount = 0;
           1            SCH_AppData.TableVerifyFailureCount = 0;
		        
           1            SCH_AppData.ValidMajorFrameCount      = 0;
           1            SCH_AppData.MissedMajorFrameCount     = 0;
           1            SCH_AppData.UnexpectedMajorFrameCount = 0;
		
           1            CFE_EVS_SendEvent(SCH_RESET_CMD_EID, CFE_EVS_DEBUG,
		                          "RESET command");
		    }
		
           2        return;
		
		} /* End of SCH_ResetCmd() */
		
		
		/*******************************************************************
		**
		** SCH_EnableCmd
		**
		** NOTE: For complete prolog information, see above
		********************************************************************/
		
		void SCH_EnableCmd(CFE_SB_MsgPtr_t MessagePtr)
           6    {
           6        boolean         GoodCommand = FALSE;
           6        SCH_EntryCmd_t *EnableCmd = NULL;
           6        uint16          SlotNumber = 0; 
           6        uint16          EntryNumber = 0;
           6        uint16          TableIndex = 0;
		    
		    /*
		    ** Extract contents of command
		    */
           6        EnableCmd   = (SCH_EntryCmd_t *) MessagePtr;
		
           6        if(SCH_VerifyCmdLength(MessagePtr, sizeof(SCH_EntryCmd_t)) == SCH_SUCCESS)
		    {
           5            SlotNumber  = EnableCmd->SlotNumber;
           5            EntryNumber = EnableCmd->EntryNumber;
           5            TableIndex  = (SlotNumber * SCH_ENTRIES_PER_SLOT) + EntryNumber;
		
           5            if ((SlotNumber >= SCH_TOTAL_SLOTS) || (EntryNumber >= SCH_ENTRIES_PER_SLOT))
		        {
		            /*
		            ** Invalid command packet argument
		            */
           2                CFE_EVS_SendEvent(SCH_ENABLE_CMD_ARG_ERR_EID, CFE_EVS_ERROR,
		                              "ENABLE cmd: invalid argument, slot=%d (<%d), entry=%d (<%d)",
		                              SlotNumber, SCH_TOTAL_SLOTS, 
		                              EntryNumber, SCH_ENTRIES_PER_SLOT);
		        }
           3            else if ((SCH_AppData.ScheduleTable[TableIndex].EnableState != SCH_ENABLED) &&
		                 (SCH_AppData.ScheduleTable[TableIndex].EnableState != SCH_DISABLED))
		        {
		            /*
		            ** Invalid schedule table enable state (unused or corrupt)
		            */
           1                CFE_EVS_SendEvent(SCH_ENABLE_CMD_ENTRY_ERR_EID, CFE_EVS_ERROR,
		                              "ENABLE command: invalid state = %d, slot = %d, entry = %d",
		                              SCH_AppData.ScheduleTable[TableIndex].EnableState,
		                              SlotNumber, EntryNumber);
		        }
		        else
		        {
		            /*
		            ** Success
		            */
           2                GoodCommand = TRUE;
		    
           2                SCH_AppData.ScheduleTable[TableIndex].EnableState = SCH_ENABLED;
		    
           2                CFE_EVS_SendEvent(SCH_ENABLE_CMD_EID, CFE_EVS_DEBUG,
		                              "ENABLE command: slot = %d, entry = %d",
		                              SlotNumber, EntryNumber );
		        }
		    }
		
           6        SCH_PostCommandResult(GoodCommand);
		
		    return;
		
		} /* End of SCH_EnableCmd() */
		
		
		/*******************************************************************
		**
		** SCH_DisableCmd
		**
		** NOTE: For complete prolog information, see above
		********************************************************************/
		
		void SCH_DisableCmd(CFE_SB_MsgPtr_t MessagePtr)
           5    {
           5        boolean         GoodCommand = FALSE;
           5        SCH_EntryCmd_t *DisableCmd  = NULL;
           5        uint16          SlotNumber  = 0;
           5        uint16          EntryNumber = 0;
           5        uint16          TableIndex  = 0;
		
		    /*
		    ** Extract contents of command
		    */
           5        DisableCmd  = (SCH_EntryCmd_t *) MessagePtr;
		
           5        if(SCH_VerifyCmdLength(MessagePtr, sizeof(SCH_EntryCmd_t)) == SCH_SUCCESS)
		    {
           4            SlotNumber  = DisableCmd->SlotNumber;
           4            EntryNumber = DisableCmd->EntryNumber;
           4            TableIndex  = (SlotNumber * SCH_ENTRIES_PER_SLOT) + EntryNumber;
		
           4            if ((SlotNumber >= SCH_TOTAL_SLOTS) || (EntryNumber >= SCH_ENTRIES_PER_SLOT))
		        {
		            /*
		            ** Invalid command packet argument
		            */
           2                CFE_EVS_SendEvent(SCH_DISABLE_CMD_ARG_ERR_EID, CFE_EVS_ERROR,
		                              "DISABLE cmd: invalid argument, slot=%d (<%d), entry=%d (<%d)",
		                              SlotNumber, SCH_TOTAL_SLOTS, 
		                              EntryNumber, SCH_ENTRIES_PER_SLOT);
		        }
           2            else if ((SCH_AppData.ScheduleTable[TableIndex].EnableState != SCH_ENABLED) &&
		                 (SCH_AppData.ScheduleTable[TableIndex].EnableState != SCH_DISABLED))
		        {
		            /*
		            ** Invalid schedule table enable state (unused or corrupt)
		            */
           1                CFE_EVS_SendEvent(SCH_DISABLE_CMD_ENTRY_ERR_EID, CFE_EVS_ERROR,
		                              "DISABLE command: invalid state = %d, slot = %d, entry = %d",
		                              SCH_AppData.ScheduleTable[TableIndex].EnableState,
		                              SlotNumber, EntryNumber);
		        }
		        else
		        {
		            /*
		            ** Success
		            */
           1                GoodCommand = TRUE;
		    
           1                SCH_AppData.ScheduleTable[TableIndex].EnableState = SCH_DISABLED;
		    
           1                CFE_EVS_SendEvent(SCH_DISABLE_CMD_EID, CFE_EVS_DEBUG,
		                              "DISABLE command: slot = %d, entry = %d",
		                              SlotNumber, EntryNumber);
		        }
		    }
		
           5        SCH_PostCommandResult(GoodCommand);
		
		    return;
		
		} /* End of SCH_DisableCmd() */
		
		
		/*******************************************************************
		**
		** SCH_EnableGroupCmd
		**
		** NOTE: For complete prolog information, see above
		********************************************************************/
		
		void SCH_EnableGroupCmd(CFE_SB_MsgPtr_t MessagePtr)
           6    {
           6        boolean              GoodCommand = FALSE;
           6        uint32               TblGroupNumber = 0;
           6        uint32               TblMultiGroup = 0;
           6        int32                LoopCount = 0;
           6        int32                MatchCount = 0;
           6        SCH_GroupCmd_t      *EnableCmd = NULL;
           6        SCH_ScheduleEntry_t *TableEntry = NULL;
           6        uint32               CmdGroupNumber = 0;
           6        uint32               CmdMultiGroup  = 0;
		
		    /*
		    ** Extract command parameters
		    */
           6        EnableCmd = (SCH_GroupCmd_t *) MessagePtr;
		
           6        if(SCH_VerifyCmdLength(MessagePtr, sizeof(SCH_GroupCmd_t)) == SCH_SUCCESS)
		    {
           5            TableEntry = &SCH_AppData.ScheduleTable[0];
           5            CmdGroupNumber = EnableCmd->GroupData & SCH_GROUP_NUMBER_BIT_MASK;
           5            CmdMultiGroup  = EnableCmd->GroupData & SCH_MULTI_GROUP_BIT_MASK;
		
           5            if ((CmdGroupNumber == SCH_UNUSED) && (CmdMultiGroup == SCH_UNUSED))
		        {
		            /*
		            ** No groups selected
		            */
           1                CFE_EVS_SendEvent(SCH_ENA_GRP_CMD_ERR_EID, CFE_EVS_ERROR,
		                              "ENABLE GROUP command: invalid argument, no groups selected");
		        }
		        else
		        {
		            /*
		            ** Search entire schedule table for group members
		            */
        2004                for (LoopCount = 0; LoopCount < SCH_TABLE_ENTRIES; LoopCount++)
		            {
		                /*
		                ** Skip unused table entries
		                */
        2000                    if (TableEntry->GroupData != SCH_UNUSED)
		                {
          44                        TblGroupNumber = TableEntry->GroupData & SCH_GROUP_NUMBER_BIT_MASK;
          44                        TblMultiGroup  = TableEntry->GroupData & SCH_MULTI_GROUP_BIT_MASK;
		    
		                    /*
		                    ** Look for matching table entries
		                    */
          44                        if (((CmdGroupNumber != SCH_UNUSED) && (CmdGroupNumber == TblGroupNumber)) ||
		                        ((CmdMultiGroup & TblMultiGroup) != SCH_UNUSED))
		                    {
          10                            MatchCount++;
          10                            TableEntry->EnableState = SCH_ENABLED;
		                    }
		                }
		    
        2000                    TableEntry++;
		            }
		
           4                if (MatchCount > 0)
		            {
           3                    CFE_EVS_SendEvent(SCH_ENA_GRP_CMD_EID, CFE_EVS_DEBUG,
		                                  "ENABLE GROUP command: match count = %d",
		                                  MatchCount);
           3                    GoodCommand = TRUE;
		            }
		            else
		            {
           1                    CFE_EVS_SendEvent(SCH_ENA_GRP_NOT_FOUND_ERR_EID, CFE_EVS_ERROR,
		                                  "ENABLE GROUP command: Neither Group %d nor Multi-Group 0x%06X found",
		                                  (CmdGroupNumber>>24), CmdMultiGroup);
		            }
		        }
		    }
		
           6        SCH_PostCommandResult(GoodCommand);
		
		    return;
		
		} /* End of SCH_EnableGroupCmd() */
		
		
		/*******************************************************************
		**
		** SCH_DisableGroupCmd
		**
		** NOTE: For complete prolog information, see above
		********************************************************************/
		
		void SCH_DisableGroupCmd(CFE_SB_MsgPtr_t MessagePtr)
           6    {
           6        boolean              GoodCommand = FALSE;
           6        uint32               TblGroupNumber = 0;
           6        uint32               TblMultiGroup = 0;
           6        int32                LoopCount = 0;
           6        int32                MatchCount = 0;
           6        SCH_GroupCmd_t      *DisableCmd = NULL;
           6        SCH_ScheduleEntry_t *TableEntry = NULL;
           6        uint32               CmdGroupNumber = 0;
           6        uint32               CmdMultiGroup  = 0;
		
		    /*
		    ** Extract command parameters
		    */
           6        DisableCmd = (SCH_GroupCmd_t *) MessagePtr;
		
           6        if(SCH_VerifyCmdLength(MessagePtr, sizeof(SCH_GroupCmd_t)) == SCH_SUCCESS)
		    {
           5            TableEntry = &SCH_AppData.ScheduleTable[0];
           5            CmdGroupNumber = DisableCmd->GroupData & SCH_GROUP_NUMBER_BIT_MASK;
           5            CmdMultiGroup  = DisableCmd->GroupData & SCH_MULTI_GROUP_BIT_MASK;
		
           5            if ((CmdGroupNumber == SCH_UNUSED) && (CmdMultiGroup == SCH_UNUSED))
		        {
		            /*
		            ** No groups selected
		            */
           1                CFE_EVS_SendEvent(SCH_DIS_GRP_CMD_ERR_EID, CFE_EVS_ERROR,
		                              "DISABLE GROUP command: invalid argument, no groups selected");
		        }
		        else
		        {
		            /*
		            ** Search entire schedule table for group members
		            */
        2004                for (LoopCount = 0; LoopCount < SCH_TABLE_ENTRIES; LoopCount++)
		            {
		                /*
		                ** Skip unused table entries
		                */
        2000                    if (TableEntry->GroupData != SCH_UNUSED)
		                {
          48                        TblGroupNumber = TableEntry->GroupData & SCH_GROUP_NUMBER_BIT_MASK;
          48                        TblMultiGroup  = TableEntry->GroupData & SCH_MULTI_GROUP_BIT_MASK;
		    
		                    /*
		                    ** Look for matching table entries
		                    */
          48                        if (((CmdGroupNumber != SCH_UNUSED) && (CmdGroupNumber == TblGroupNumber)) ||
		                        ((CmdMultiGroup & TblMultiGroup) != SCH_UNUSED))
		                    {
          10                            MatchCount++;
          10                            TableEntry->EnableState = SCH_DISABLED;
		                    }
		                }
		    
        2000                    TableEntry++;
		            }
		
           4                if (MatchCount > 0)
		            {
           3                    CFE_EVS_SendEvent(SCH_DIS_GRP_CMD_EID, CFE_EVS_DEBUG,
		                                  "DISABLE GROUP command: match count = %d",
		                                  MatchCount);
           3                    GoodCommand = TRUE;
		            }
		            else
		            {
           1                    CFE_EVS_SendEvent(SCH_DIS_GRP_NOT_FOUND_ERR_EID, CFE_EVS_ERROR,
		                                  "DISABLE GROUP command: Neither Group %d nor Multi-Group 0x%06X found",
		                                  (CmdGroupNumber>>24), CmdMultiGroup);
		            }
		        }
		    }
		
           6        SCH_PostCommandResult(GoodCommand);
		
		    return;
		
		} /* End of SCH_DisableGroupCmd() */
		
		
		/*******************************************************************
		**
		** SCH_EnableSyncCmd
		**
		** NOTE: For complete prolog information, see above
		********************************************************************/
		
		void SCH_EnableSyncCmd(CFE_SB_MsgPtr_t MessagePtr)
           2    {
           2        boolean   GoodCommand = FALSE;
		
           2        if(SCH_VerifyCmdLength(MessagePtr, sizeof(SCH_NoArgsCmd_t)) == SCH_SUCCESS)
		    {
           1            GoodCommand = TRUE;
		        
           1            SCH_AppData.IgnoreMajorFrame = FALSE;
           1            SCH_AppData.UnexpectedMajorFrame = FALSE;
           1            SCH_AppData.ConsecutiveNoisyFrameCounter = 0;
		        
           1            CFE_EVS_SendEvent(SCH_ENA_SYNC_CMD_EID, CFE_EVS_DEBUG,
		                          "Major Frame Synchronization Enabled");
		    }
		
           2        SCH_PostCommandResult(GoodCommand);
		
		    return;
		
		} /* End of SCH_EnableSyncCmd() */
		
		
		
		
		/*******************************************************************
		**
		** SCH_SendDiagTlmCmd
		**
		** NOTE: For complete prolog information, see above
		********************************************************************/
		
		void SCH_SendDiagTlmCmd(CFE_SB_MsgPtr_t MessagePtr)
          29    {
          29        boolean              GoodCommand = FALSE;
          29        uint32               TblIndex = 0;
          29        uint32               WordIndex = 0;
          29        uint32               BitIndex = 0;
          29        SCH_ScheduleEntry_t *TableEntry = NULL;
		
          29        if(SCH_VerifyCmdLength(MessagePtr, sizeof(SCH_NoArgsCmd_t)) == SCH_SUCCESS)
		    {
          28            GoodCommand = TRUE;
		        
		        /* Zero out the previous entry states */
          28            CFE_PSP_MemSet(&SCH_AppData.DiagPacket.EntryStates[0], 0x0, SCH_NUM_STATUS_BYTES_REQD);
		        
       14028            for (TblIndex=0; TblIndex<SCH_TABLE_ENTRIES; TblIndex++)
		        {
       14000                TableEntry = &SCH_AppData.ScheduleTable[TblIndex];
       14000                WordIndex = TblIndex/8;             /* 8 states can fit in each word */
       14000                BitIndex  = (7-(TblIndex%8))*2;     /* Determine bit pair, MSBs contain lowest index */
		            
       14000                if (TableEntry->EnableState == SCH_ENABLED)
		            {
         144                    SCH_AppData.DiagPacket.EntryStates[WordIndex] |= (1 << BitIndex);
         144                    SCH_AppData.DiagPacket.MsgIDs[TblIndex] = 
		                  CFE_SB_GetMsgId((CFE_SB_MsgPtr_t)&SCH_AppData.MessageTable[SCH_AppData.ScheduleTable[TblIndex].MessageIndex]);
		            }
       13856                else if (TableEntry->EnableState == SCH_DISABLED)
		            {
         138                    SCH_AppData.DiagPacket.EntryStates[WordIndex] |= (2 << BitIndex);
         138                    SCH_AppData.DiagPacket.MsgIDs[TblIndex] = 
		                  CFE_SB_GetMsgId((CFE_SB_MsgPtr_t)&SCH_AppData.MessageTable[SCH_AppData.ScheduleTable[TblIndex].MessageIndex]);
		            }
		            else
		            {
       13718                    SCH_AppData.DiagPacket.MsgIDs[TblIndex] = 0x0000;
		            }
		        }
		        /*
		        ** Timestamp and send diagnostic packet
		        */
          28            CFE_SB_TimeStampMsg((CFE_SB_Msg_t *) &SCH_AppData.DiagPacket);
          28            CFE_SB_SendMsg((CFE_SB_Msg_t *) &SCH_AppData.DiagPacket);
		
          28            CFE_EVS_SendEvent(SCH_SEND_DIAG_CMD_EID, CFE_EVS_DEBUG,
		                          "Transmitting Diagnostic Message");
		    }
		
          29        SCH_PostCommandResult(GoodCommand);
		
		    return;
		
		} /* End of SCH_SendDiagTlmCmd() */
		
		
		/*******************************************************************
		**
		** SCH_AcquirePointers
		**
		** NOTE: For complete prolog information, see 'sch_cmds.h'
		********************************************************************/
		
		int32 SCH_AcquirePointers(void)
          75    {
          75        int32  Result;
		
		    /*
		    ** Let cFE manage the tables
		    */
          75        CFE_TBL_Manage(SCH_AppData.ScheduleTableHandle);
          75        CFE_TBL_Manage(SCH_AppData.MessageTableHandle);
		
		    /*
		    ** Get a pointer to the schedule table
		    */
          75        Result = CFE_TBL_GetAddress((void *)&SCH_AppData.ScheduleTable, 
		                                         SCH_AppData.ScheduleTableHandle);
		
          75        if (Result > CFE_SUCCESS)
		    {
		        /*
		        ** Change warning results to indicate "success"
		        */
           7            Result = CFE_SUCCESS;
		    }
		
		    /*
		    ** Repeat the process for the message table
		    */
          75        if (Result == CFE_SUCCESS)
		    {
          74            Result = CFE_TBL_GetAddress((void *)&SCH_AppData.MessageTable, 
		                                             SCH_AppData.MessageTableHandle);
          74            if (Result > CFE_SUCCESS)
		        {
           6                Result = CFE_SUCCESS;
		        }
		    }
		
          75        return(Result);
		
		} /* End of SCH_AcquirePointers() */
		
		
		/*******************************************************************
		**
		** SCH_VerifyCmdLength
		**
		** NOTE: For complete prolog information, see above
		********************************************************************/
		
		int32 SCH_VerifyCmdLength (CFE_SB_MsgPtr_t MessagePtr, uint32 ExpectedLength)
         129    {
         129        int32               Status = SCH_SUCCESS;
         129        CFE_SB_MsgId_t      MessageID = 0;
         129        uint16              CommandCode = 0; 
         129        uint16              ActualLength = 0;
		   
         129        ActualLength  = CFE_SB_GetTotalMsgLength(MessagePtr);
		      
         129        if (ExpectedLength != ActualLength)
		    {
           9            MessageID   = CFE_SB_GetMsgId(MessagePtr);
           9            CommandCode = CFE_SB_GetCmdCode(MessagePtr);   
		         
           9            CFE_EVS_SendEvent(SCH_CMD_LEN_ERR_EID, CFE_EVS_ERROR,
		                          "Cmd Msg with Bad length Rcvd: ID = 0x%04X, CC = %d, Exp Len = %d, Len = %d",
		                          MessageID, CommandCode, ExpectedLength, ActualLength);
		
           9            Status = SCH_BAD_MSG_LENGTH_RC;
		    }
		
         129        return Status;
		
		} /* End of SCH_VerifyCmdLength () */
		
		
		/*******************************************************************
		**
		** SCH_PostCommandResult
		**
		** NOTE: For complete prolog information, see above
		********************************************************************/
		
		void SCH_PostCommandResult(boolean GoodCommand)
          54    {
          54        if (GoodCommand)
		    {
          38            SCH_AppData.CmdCounter++;
		    }
		    else
		    {
          16            SCH_AppData.ErrCounter++;
		    }
		
          54        return;
		
		} /* End of SCH_PostCommandResult() */
		
		
		
		/************************/
		/*  End of File Comment */
		/************************/
		
